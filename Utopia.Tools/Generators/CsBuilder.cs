// This file is a part of the project Utopia(Or is a part of its subproject).
// Copyright 2020-2023 mingmoe(http://kawayi.moe)
// The file was licensed under the AGPL 3.0-or-later license

using System.Diagnostics;
using System.Text;

namespace Utopia.Tools.Generators;

public class CsBuilder
{
    private int _alignCount = 0;

    private string _Align => new(' ', _alignCount * 4);

    public List<string> Usings = new();

    public string? Namespace = null;

    public List<string> Lines = new();

    public Type? Generator = null;

    public string[] Source;

    public void EmitClass(string className, bool isPublic = false, bool isStatic = false, bool isPartial = false, params string[] parentClass)
    {
        string pub = isPublic ? "public" : string.Empty;
        string sat = isStatic ? "static" : string.Empty;
        string prt = isPartial ? "partial" : string.Empty;

        string parent = parentClass.Length == 0 ? string.Empty : " : ";
        foreach (string c in parentClass)
        {
            parent += $"{c},";
        }
        if (parentClass.Length != 0)
        {
            parent = parent[0..^1];
        }

        Lines.Add($"{_Align}{pub} {sat} {prt} class {className} {parent}");
        BeginCodeBlock();
    }

    public void BeginCodeBlock()
    {
        Lines.Add("{");
        _alignCount++;
    }

    public void CloseCodeBlock()
    {
        if (_alignCount <= 0)
        {
            throw new InvalidOperationException("all blocks have been closed");
        }

        _alignCount--;
        Lines.Add("}");
    }

    public void EmitComment(string comment, bool forceMultiline = false)
    {
        string[] lines = comment.Split(new[] { '\r', '\n' });
        if (lines.Length == 1 && (!forceMultiline))
        {
            Lines.Add($"{_Align}// {comment}");
        }
        else
        {
            Lines.Add($"{_Align}/*");
            foreach (string line in lines)
            {
                Lines.Add($"{_Align} * {line}");
            }
            Lines.Add($"{_Align} */");
        }
    }

    public void EmitLine(string line, int alignFix = 0)
    {
        int origin = _alignCount;
        _alignCount = origin + alignFix;
        Lines.Add($"{_Align}{line}");
        _alignCount = origin;
    }

    public void EmitProperty(string accessibility, string type, string name, bool isStatic = false)
    {
        string @static = isStatic ? "static" : string.Empty;

        Lines.Add($"{_Align}{accessibility} {@static} {type} {name} {{ get; set; }}");
    }

    public void EmitField(string accessibility, string type, string name, string? defaultValue = null, bool isReadonly = false, bool isStatic = false)
    {
        string @static = isStatic ? "static" : string.Empty;
        string @readonly = isReadonly ? "readonly" : string.Empty;
        string @value = defaultValue != null ? " = " + defaultValue : string.Empty;

        Lines.Add($"{_Align}{accessibility} {@static} {@readonly} {type} {name}{@value};");
    }

    public string Generate()
    {
        StringBuilder sb = new();

        _ = sb.AppendLine("// This file was generated by source generator:" + Generator?.FullName ?? string.Empty);
        _ = sb.AppendLine("// This file was generated from file:");

        foreach (string source in Source)
        {
            _ = sb.AppendLine("// " + source);
        }
        _ = sb.AppendLine();

        foreach (string s in Usings)
        {
            _ = sb.Append("using ").Append(s).AppendLine(";");
        }

        if (Namespace != null)
        {
            _ = sb.AppendLine($"namespace {Namespace};");
        }

        _ = sb.AppendLine();

        foreach (string s in Lines)
        {
            _ = sb.AppendLine(s);
        }

        return sb.ToString();
    }

    public CsBuilder(params string[] source)
    {
        System.Reflection.MethodBase? methodInfo = new StackTrace().GetFrame(1)?.GetMethod();
        Generator = methodInfo?.ReflectedType;
        Source = source;
    }
}
